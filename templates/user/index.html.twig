{% extends 'base.html.twig' %}

{% block title %}Users{% endblock %}

{% block stylesheets %}
    <style>
        /* General styles */
        .user-list-column { width: 30%; float: left; padding-right: 15px; }
        .backlog-column { width: 70%; float: left; padding-left: 15px; }
        .user-row.selected { background-color: #e2f0e2 !important; }
        .loading-spinner { display: none; text-align: center; padding: 20px; }
        .loading-spinner i { font-size: 2rem; }

        {% include 'partials/action_styles.html.twig' %}

        /* Center align status column */
        #backlog-table th:nth-child(6),
        #backlog-table td:nth-child(6) { text-align: center; }

        /* Notes badge styling */
        #notes-badge {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 20px;
            height: 20px;
            font-size: 0.75rem;
            margin-left: 5px;
            padding: 0;
            border-radius: 50%;
            background-color: #dc3545;
            color: white;
            font-weight: bold;
            text-align: center;
            line-height: 1;
        }

        /* Disabled user styling */
        .disabled-user {
            color: #dc3545;
            font-style: italic;
        }

        /* Dynamic height with scrolling for users list */
        .user-list-column .card-body {
            overflow: hidden;
        }

        .user-list-column .table-responsive {
            overflow-y: auto;
        }

        /* Expanded panel styling */
        .panel-expanded .card-body {
            max-height: calc(100vh - 200px); /* Dynamic height that leaves room for headers and margins */
        }

        .panel-expanded .table-responsive {
            max-height: calc(100vh - 240px); /* Slightly less than card-body to account for padding */
        }

        /* Collapsed panel styling */
        .panel-collapsed .card-body {
            display: none;
        }

        /* Keep the table header fixed */
        .user-list-column .table thead,
        .backlog-column .table thead {
            position: sticky;
            top: 0;
            background-color: #fff;
            z-index: 1;
        }

        /* Panel header styling */
        .panel-header {
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .panel-header:hover {
            filter: brightness(1.1);
        }

        .panel-icon {
            margin-right: 8px;
            transition: transform 0.2s;
        }

        /* Responsive layout */
        @media (max-width: 768px) {
            .user-list-column, .backlog-column { width: 100%; float: none; padding: 0; }
            .backlog-column { margin-top: 20px; }
        }
    </style>
{% endblock %}

{% block body %}
    <div id="notification-container" style="position: fixed; top: 20px; right: 20px; z-index: 1050;"></div>

    {# Add CSRF token for user creation #}
    <input type="hidden" name="_token" id="csrf_token" value="{{ csrf_token('create_user') }}">

    <div class="row mb-4">
        <div class="clearfix">
            <div class="user-list-column">
                <!-- Enabled Users Panel -->
                <div class="card mb-3">
                    <div class="card-header bg-success text-white d-flex justify-content-between align-items-center panel-header" data-panel="enabled-users">
                        <h4 class="mb-0"><i class="fas fa-minus panel-icon"></i> Enabled Users</h4>
                        <button type="button" class="btn btn-light" id="create-user-btn">
                            <i class="fas fa-plus"></i> Create User
                        </button>
                    </div>
                    <div class="card-body">
                        <div class="table-responsive">
                            <table class="table">
                                <thead>
                                <tr>
                                    <th>ID</th>
                                    <th>User</th>
                                    <th>Actions</th>
                                </tr>
                                </thead>
                                <tbody>
                                <!-- Form row for creating new user -->
                                <tr id="user-form-row" style="display: none;">
                                    <td><i>New</i></td>
                                    <td>
                                        <div class="mb-2">
                                            <input type="text" class="form-control" id="user-username" name="username" placeholder="Username" required>
                                        </div>
                                        <div class="mb-2">
                                            <input type="email" class="form-control" id="user-email" name="email" placeholder="Email" required>
                                        </div>
                                    </td>
                                    <td>
                                        <div class="mb-2">
                                            <input type="password" class="form-control" id="user-password" name="password" placeholder="Password" required>
                                        </div>
                                        <button type="button" id="save-user-btn" class="btn btn-sm btn-success text-white">Save</button>
                                        <button type="button" id="cancel-user-btn" class="btn btn-sm btn-secondary">Cancel</button>
                                    </td>
                                </tr>
                                {% for user in users %}
                                    {% if not user.disabled %}
                                    <tr class="user-row" data-user-id="{{ user.id }}" data-username="{{ user.username }}" style="cursor: pointer;">
                                        <td>{{ user.id }}</td>
                                        <td>{{ user.username }} <span class="text-muted">({{ user.email }})</span></td>
                                        <td>
                                            <a href="{{ path('app_user_edit', {'id': user.id}) }}" class="btn btn-sm btn-outline-success" data-bs-toggle="tooltip" title="Edit">
                                                <i class="fas fa-pencil-alt"></i>
                                            </a>
                                        </td>
                                    </tr>
                                    {% endif %}
                                {% else %}
                                    <tr>
                                        <td colspan="3" class="text-center">No users found</td>
                                    </tr>
                                {% endfor %}
                                {% if users|filter(user => not user.disabled)|length == 0 %}
                                    <tr>
                                        <td colspan="3" class="text-center">No enabled users found</td>
                                    </tr>
                                {% endif %}
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>

                <!-- Disabled Users Panel -->
                <div class="card">
                    <div class="card-header bg-secondary text-white d-flex justify-content-between align-items-center panel-header" data-panel="disabled-users">
                        <h4 class="mb-0"><i class="fas fa-plus panel-icon"></i> Disabled Users</h4>
                    </div>
                    <div class="card-body">
                        <div class="table-responsive">
                            <table class="table">
                                <thead>
                                <tr>
                                    <th>ID</th>
                                    <th>User</th>
                                    <th>Actions</th>
                                </tr>
                                </thead>
                                <tbody>
                                {% for user in users %}
                                    {% if user.disabled %}
                                    <tr class="user-row disabled-user table-secondary" data-user-id="{{ user.id }}" data-username="{{ user.username }}" style="cursor: pointer;">
                                        <td>{{ user.id }}</td>
                                        <td>{{ user.username }} <span class="text-muted">({{ user.email }})</span></td>
                                        <td>
                                            <a href="{{ path('app_user_edit', {'id': user.id}) }}" class="btn btn-sm btn-outline-success" data-bs-toggle="tooltip" title="Edit">
                                                <i class="fas fa-pencil-alt"></i>
                                            </a>
                                        </td>
                                    </tr>
                                    {% endif %}
                                {% endfor %}
                                {% if users|filter(user => user.disabled)|length == 0 %}
                                    <tr>
                                        <td colspan="3" class="text-center">No disabled users found</td>
                                    </tr>
                                {% endif %}
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>
            </div>

            <div class="backlog-column">
                <div id="backlog-container" class="card">
                    <div class="card-header bg-success text-white">
                        <h4 class="mb-0" id="backlog-header">Backlog</h4>
                    </div>
                    <div class="card-body">
                        <div id="no-user-selected-message" class="text-center">
                            <p class="mb-0">Select a user to view their backlog.</p>
                        </div>
                        <div id="loading-spinner" class="loading-spinner">
                            <i class="fas fa-spinner fa-spin"></i>
                            <p>Loading backlog...</p>
                        </div>
                        <div id="backlog-content" style="display: none;">
                            <div class="table-responsive" style="max-height: 70vh; overflow-y: auto;">
                                <!-- Open Actions Table -->
                                <h5>Open Actions</h5>
                                <table id="open-backlog-table" class="table table-striped mb-4">
                                    <thead>
                                    <tr>
                                        <th>ID</th>
                                        <th>Account</th>
                                        <th>Action</th>
                                        <th>Contact</th>
                                        <th>Action Date</th>
                                        <th>Status</th>
                                        <th>Notes <span id="open-notes-badge" class="badge rounded-circle bg-danger" style="display: none;"></span></th>
                                    </tr>
                                    </thead>
                                    <tbody id="open-backlog-tbody">
                                    </tbody>
                                </table>

                                <!-- Closed Actions Table -->
                                <h5>Closed Actions</h5>
                                <table id="closed-backlog-table" class="table table-striped">
                                    <thead>
                                    <tr>
                                        <th>ID</th>
                                        <th>Account</th>
                                        <th>Action</th>
                                        <th>Contact</th>
                                        <th>Action Date</th>
                                        <th>Status</th>
                                        <th>Closed At</th>
                                        <th>Notes <span id="closed-notes-badge" class="badge rounded-circle bg-danger" style="display: none;"></span></th>
                                    </tr>
                                    </thead>
                                    <tbody id="closed-backlog-tbody">
                                    </tbody>
                                </table>
                            </div>
                            <div id="no-actions-message" class="text-center mt-3" style="display: none;">
                                <p>This user has no actions to display.</p>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="modal fade" id="notesModal" tabindex="-1" aria-hidden="true">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header bg-info text-white">
                    <h5 class="modal-title">Action Notes</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                </div>
                <div class="modal-body">
                    <textarea id="notes-content" class="form-control" rows="5"></textarea>
                    <input type="hidden" id="action-id-for-notes">
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                    <button type="button" class="btn btn-primary" id="save-notes-btn">Save</button>
                </div>
            </div>
        </div>
    </div>
{% endblock %}

{% block javascripts %}
    <script>
        document.addEventListener('DOMContentLoaded', function () {
            // Panel expand/collapse functionality
            const panelHeaders = document.querySelectorAll('.panel-header');

            // Set initial state - Enabled expanded, Disabled collapsed
            const enabledPanel = document.querySelector('[data-panel="enabled-users"]').closest('.card');
            const disabledPanel = document.querySelector('[data-panel="disabled-users"]').closest('.card');

            // Function to set panel state
            function setPanelState(panel, isExpanded) {
                const panelBody = panel.querySelector('.card-body');
                const panelIcon = panel.querySelector('.panel-icon');

                if (isExpanded) {
                    // Expand panel
                    panel.classList.add('panel-expanded');
                    panel.classList.remove('panel-collapsed');
                    panelIcon.classList.remove('fa-plus');
                    panelIcon.classList.add('fa-minus');
                } else {
                    // Collapse panel
                    panel.classList.remove('panel-expanded');
                    panel.classList.add('panel-collapsed');
                    panelIcon.classList.remove('fa-minus');
                    panelIcon.classList.add('fa-plus');
                }
            }

            // Set initial states
            setPanelState(enabledPanel, true);
            setPanelState(disabledPanel, false);

            // Add click event listeners to panel headers
            panelHeaders.forEach(header => {
                header.addEventListener('click', function(e) {
                    // Don't trigger if clicking on the Create User button
                    if (e.target.closest('#create-user-btn')) {
                        return;
                    }

                    const panel = this.closest('.card');
                    const otherPanel = panel === enabledPanel ? disabledPanel : enabledPanel;

                    // Check if panel is currently collapsed
                    const isCollapsed = panel.classList.contains('panel-collapsed');

                    if (isCollapsed) {
                        // Expand this panel and collapse the other
                        setPanelState(panel, true);
                        setPanelState(otherPanel, false);
                    }
                });
            });

            // Handle window resize to adjust panel heights
            function adjustPanelHeights() {
                const expandedPanel = document.querySelector('.panel-expanded');
                if (expandedPanel) {
                    // Force a small repaint to ensure the panel adjusts to the new window size
                    expandedPanel.style.maxHeight = 'none';
                    setTimeout(() => {
                        expandedPanel.style.maxHeight = '';
                    }, 0);
                }
            }

            // Listen for window resize events
            window.addEventListener('resize', adjustPanelHeights);

            // Trigger initial adjustment when the page loads
            window.addEventListener('load', adjustPanelHeights);
            // --- STATE MANAGEMENT ---
            let userBacklogActions = [];
            let currentUserId = null;
            const notesModal = new bootstrap.Modal(document.getElementById('notesModal'));

            // --- USER CREATION LOGIC ---
            const createUserBtn = document.getElementById('create-user-btn');
            const userFormRow = document.getElementById('user-form-row');
            const saveUserBtn = document.getElementById('save-user-btn');
            const cancelUserBtn = document.getElementById('cancel-user-btn');

            if (createUserBtn) {
                // Show the form row when Create User button is clicked
                createUserBtn.addEventListener('click', function() {
                    // Show the form row
                    userFormRow.style.display = 'table-row';

                    // Focus on the username input
                    document.getElementById('user-username').focus();
                });

                // Handle cancel button
                cancelUserBtn.addEventListener('click', function() {
                    // Hide the form row
                    userFormRow.style.display = 'none';

                    // Reset form fields
                    document.getElementById('user-username').value = '';
                    document.getElementById('user-email').value = '';
                    document.getElementById('user-password').value = '';
                });

                // Handle save button
                saveUserBtn.addEventListener('click', function() {
                    // Validate required fields
                    const username = document.getElementById('user-username').value;
                    const email = document.getElementById('user-email').value;
                    const password = document.getElementById('user-password').value;

                    if (!username) {
                        showNotification('Username is required', 'danger');
                        return;
                    }

                    if (!email) {
                        showNotification('Email is required', 'danger');
                        return;
                    }

                    if (!password) {
                        showNotification('Password is required', 'danger');
                        return;
                    }

                    // Create FormData object
                    const formData = new FormData();
                    formData.append('username', username);
                    formData.append('email', email);
                    formData.append('password', password);

                    // Get CSRF token from hidden input
                    const token = document.getElementById('csrf_token').value;
                    formData.append('_token', token);

                    // Send request to create user
                    fetch('/users/create-ajax', {
                        method: 'POST',
                        body: formData
                    })
                    .then(response => {
                        if (!response.ok) {
                            // Check the content type of the response
                            const contentType = response.headers.get('content-type');
                            if (contentType && contentType.includes('application/json')) {
                                // If it's JSON, parse it and extract the error message
                                return response.json().then(data => {
                                    throw new Error(data.error || 'Network response was not ok');
                                });
                            } else {
                                // If it's not JSON (likely HTML error page), throw a generic error
                                throw new Error('An error occurred while creating the user. Please check the logs or contact support.');
                            }
                        }
                        return response.json();
                    })
                    .then(data => {
                        // Hide the form row
                        userFormRow.style.display = 'none';

                        // Reset form fields
                        document.getElementById('user-username').value = '';
                        document.getElementById('user-email').value = '';
                        document.getElementById('user-password').value = '';

                        // Add the new user to the table
                        const row = document.createElement('tr');
                        row.className = 'user-row';
                        row.setAttribute('data-user-id', data.id);
                        row.setAttribute('data-username', data.username);
                        row.style.cursor = 'pointer';
                        row.innerHTML = `
                            <td>${data.id}</td>
                            <td>${data.username} <span class="text-muted">(${data.email})</span></td>
                            <td>
                                <a href="/users/${data.id}/edit" class="btn btn-sm btn-outline-success" data-bs-toggle="tooltip" title="Edit">
                                    <i class="fas fa-pencil-alt"></i>
                                </a>
                            </td>
                        `;

                        // Add the new row after the form row
                        if (userFormRow.nextSibling) {
                            userFormRow.parentNode.insertBefore(row, userFormRow.nextSibling);
                        } else {
                            userFormRow.parentNode.appendChild(row);
                        }

                        // Add click event listener to the new row
                        row.addEventListener('click', function() {
                            userRows.forEach(r => r.classList.remove('selected'));
                            this.classList.add('selected');
                            const userId = this.dataset.userId;
                            const username = this.dataset.username;
                            backlogHeader.textContent = `Backlog of ${username}`;
                            fetchAndRenderBacklog(userId);
                        });

                        // Show success notification
                        showNotification('User created successfully', 'success');
                    })
                    .catch(error => {
                        console.error('Error creating user:', error);
                        showNotification(error.message || 'Error creating user. Please try again.', 'danger');
                    });
                });
            }

            // --- DOM ELEMENTS ---
            const backlogContainer = document.getElementById('backlog-container');
            const backlogHeader = document.getElementById('backlog-header');
            const backlogContent = document.getElementById('backlog-content');
            const backlogTbody = document.getElementById('backlog-tbody');
            const loadingSpinner = document.getElementById('loading-spinner');
            const noUserMessage = document.getElementById('no-user-selected-message');
            const noActionsMessage = document.getElementById('no-actions-message');
            const userRows = document.querySelectorAll('.user-row');

            // --- NOTIFICATION UTILITY ---
            function showNotification(message, type = 'success', duration = 3000) {
                const container = document.getElementById('notification-container');
                const alert = document.createElement('div');
                alert.className = `alert alert-${type} alert-dismissible fade show`;
                alert.role = 'alert';
                alert.innerHTML = `${message}<button type="button" class="btn-close" data-bs-dismiss="alert"></button>`;
                container.appendChild(alert);
                setTimeout(() => new bootstrap.Alert(alert).close(), duration);
            }

            // --- RENDERING LOGIC ---
            function renderBacklog() {
                // Get references to both table bodies
                const openBacklogTbody = document.getElementById('open-backlog-tbody');
                const closedBacklogTbody = document.getElementById('closed-backlog-tbody');

                // Clear existing content in both tables
                openBacklogTbody.innerHTML = '';
                closedBacklogTbody.innerHTML = '';

                if (userBacklogActions.length === 0) {
                    noActionsMessage.style.display = 'block';
                    // Hide notes badges when no actions
                    document.getElementById('open-notes-badge').style.display = 'none';
                    document.getElementById('closed-notes-badge').style.display = 'none';
                    return;
                }
                noActionsMessage.style.display = 'none';

                // Separate actions into open and closed
                const openActions = userBacklogActions.filter(action => !action.closed);
                const closedActions = userBacklogActions.filter(action => action.closed);

                // Sort open actions by date in ascending order (soonest first)
                openActions.sort((a, b) => {
                    const dateA = a.nextStepDate ? new Date(a.nextStepDate) : new Date(9999, 11, 31);
                    const dateB = b.nextStepDate ? new Date(b.nextStepDate) : new Date(9999, 11, 31);
                    return dateA - dateB;
                });

                // Sort closed actions by dateClosed in descending order (most recently closed first)
                closedActions.sort((a, b) => {
                    const dateA = a.dateClosed ? new Date(a.dateClosed) : new Date(0);
                    const dateB = b.dateClosed ? new Date(b.dateClosed) : new Date(0);
                    return dateB - dateA;
                });

                // Calculate separate note counts for open and closed actions
                let openNotesCount = 0;
                let closedNotesCount = 0;

                // Count notes for open actions
                openActions.forEach(action => {
                    if (action.hasNotes) {
                        openNotesCount++;
                    }
                });

                // Count notes for closed actions
                closedActions.forEach(action => {
                    if (action.hasNotes) {
                        closedNotesCount++;
                    }
                });

                // Update the open notes badge
                const openNotesBadge = document.getElementById('open-notes-badge');
                if (openNotesCount > 0) {
                    openNotesBadge.textContent = openNotesCount;
                    openNotesBadge.style.display = 'inline-block';
                } else {
                    openNotesBadge.style.display = 'none';
                }

                // Update the closed notes badge
                const closedNotesBadge = document.getElementById('closed-notes-badge');
                if (closedNotesCount > 0) {
                    closedNotesBadge.textContent = closedNotesCount;
                    closedNotesBadge.style.display = 'inline-block';
                } else {
                    closedNotesBadge.style.display = 'none';
                }

                // Render open actions
                openActions.forEach(action => {
                    const row = createActionRow(action);
                    openBacklogTbody.appendChild(row);
                });

                // Render closed actions
                closedActions.forEach(action => {
                    const row = createActionRow(action);
                    closedBacklogTbody.appendChild(row);
                });

                // Initialize tooltips for disabled account icons
                const tooltipTriggerList = document.querySelectorAll('[data-bs-toggle="tooltip"]');
                [...tooltipTriggerList].map(tooltipTriggerEl => new bootstrap.Tooltip(tooltipTriggerEl));
            }

            // Helper function to create an action row
            function createActionRow(action) {
                const row = document.createElement('tr');

                // Determine row classes for styling
                row.className = '';
                // Add disabled-account-action class if the account is disabled
                if (!action.accountStatus) {
                    row.classList.add('disabled-account-action');
                }

                if (action.closed) {
                    // Closed actions - this styling takes precedence over date-based styling
                    row.classList.add('action-closed');
                } else {
                    // For non-closed actions, check if action is overdue or upcoming
                    if (action.nextStepDateRaw) {
                        // Parse dates ensuring they're treated as local dates
                        const [year, month, day] = action.nextStepDateRaw.split('-').map(Number);
                        const actionDate = new Date(year, month - 1, day); // month is 0-indexed in JS Date

                        const today = new Date();
                        today.setHours(0, 0, 0, 0); // Set to beginning of day

                        // Calculate days difference
                        const timeDiff = actionDate.getTime() - today.getTime();
                        const daysDiff = Math.ceil(timeDiff / (1000 * 3600 * 24));

                        // First check if action is overdue (in the past)
                        if (daysDiff < 0) {
                            // Overdue actions (past dates only)
                            row.classList.add('action-overdue');
                        }
                        // Only if not overdue, check if it's upcoming
                        else if (daysDiff <= 7) {
                            // Upcoming actions (today or within next 7 days)
                            row.classList.add('action-upcoming');
                        }
                    }
                }

                // Set data attribute for action ID
                row.setAttribute('data-action-id', action.id);

                row.innerHTML = `
                <td>${action.id}</td>
                <td class="action-account-cell" data-action-id="${action.id}" data-account-id="${action.accountId || ''}" data-account-status="${action.accountStatus ? 'active' : 'disabled'}">
                    <span>${action.accountName || 'N/A'}</span>
                    ${!action.accountStatus ? '<i class="fas fa-ban text-danger ms-1" data-bs-toggle="tooltip" title="The Account is disabled."></i>' : ''}
                </td>
                <td class="action-title-cell" data-action-id="${action.id}">
                    <span>${action.lastAction || ''}</span>
                    ${(action.closed || !action.accountStatus) ? '' :
                        `<i class="fas fa-pencil-alt edit-title-btn ms-2" style="cursor: pointer;"
                            data-action-id="${action.id}"></i>`
                    }
                </td>
                <td class="action-contact-cell" data-action-id="${action.id}">
                    <span>${action.contact || ''}</span>
                    ${(action.closed || !action.accountStatus) ? '' :
                        `<i class="fas fa-pencil-alt edit-contact-btn ms-2" style="cursor: pointer;"
                            data-action-id="${action.id}"></i>`
                    }
                </td>
                <td class="action-date-cell" data-action-id="${action.id}">
                    <span>${action.nextStepDateFormatted || ''}</span>
                    ${(action.closed || !action.accountStatus) ? '' :
                        `<i class="fas fa-pencil-alt edit-date-btn ms-2" style="cursor: pointer;"
                            data-action-id="${action.id}"></i>`
                    }
                </td>
                <td>
                    <input class="form-check-input action-status-checkbox" type="checkbox"
                           data-action-id="${action.id}" ${action.closed ? 'checked' : ''}>
                </td>
                <td>${action.closed && action.dateClosed ? action.dateClosed : ''}</td>
                <td class="text-center">
                    <i class="fas fa-sticky-note notes-icon" style="cursor: pointer; ${action.hasNotes ? 'color: red;' : ''}"
                       data-action-id="${action.id}" data-notes="${action.notes ? action.notes.replace(/"/g, '&quot;') : ''}"
                       data-account-id="${action.accountId}"></i>
                </td>
            `;
                return row;
            }

            // --- DATA FETCHING ---
            async function fetchAndRenderBacklog(userId) {
                currentUserId = userId;
                loadingSpinner.style.display = 'block';
                noUserMessage.style.display = 'none';
                backlogContent.style.display = 'none';

                try {
                    const response = await fetch(`/users/${userId}/account-actions`);
                    if (!response.ok) throw new Error('Failed to fetch backlog.');

                    userBacklogActions = await response.json();
                    renderBacklog();
                    backlogContent.style.display = 'block';
                } catch (error) {
                    console.error('Error fetching backlog:', error);
                    showNotification('Could not load user backlog.', 'danger');
                    noUserMessage.style.display = 'block'; // Show a message in the main area
                } finally {
                    loadingSpinner.style.display = 'none';
                }
            }

            // --- EVENT LISTENERS ---

            // 1. User row clicks
            userRows.forEach(row => {
                row.addEventListener('click', () => {
                    userRows.forEach(r => r.classList.remove('selected'));
                    row.classList.add('selected');
                    const userId = row.dataset.userId;
                    const username = row.dataset.username;
                    backlogHeader.textContent = `Backlog of ${username}`;
                    fetchAndRenderBacklog(userId);
                });
            });

            // Handle date picker changes
            document.addEventListener('change', async (e) => {
                if (!e.target.classList.contains('action-date-picker')) return;

                const actionId = e.target.getAttribute('data-action-id');
                const newDate = e.target.value;
                const originalDate = e.target.getAttribute('data-original-date');

                // If date hasn't changed, do nothing
                if (newDate === originalDate) return;

                // Disable the input while processing
                e.target.disabled = true;

                // Find the row
                const row = e.target.closest('tr');
                if (!row) {
                    console.error('Row not found for action ID:', actionId);
                    e.target.disabled = false;
                    return;
                }

                // Add a visual indicator that the action is being processed
                const originalOpacity = row.style.opacity || '1';
                row.style.opacity = '0.7';

                try {
                    const response = await fetch(`/actions/${actionId}/update-date`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/x-www-form-urlencoded',
                        },
                        body: `date=${encodeURIComponent(newDate)}`
                    });

                    if (!response.ok) throw new Error('Network response was not ok');

                    const data = await response.json();

                    // Update the action in our stored array
                    const actionIndex = userBacklogActions.findIndex(a => a.id == actionId);
                    if (actionIndex !== -1) {
                        userBacklogActions[actionIndex] = data;
                    }

                    // Update the data-original-date attribute
                    e.target.setAttribute('data-original-date', newDate);

                    // Re-render the backlog to ensure proper sorting
                    renderBacklog();

                    // Show success notification
                    showNotification('Action date updated successfully', 'success');

                } catch (error) {
                    console.error('Error updating action date:', error);
                    showNotification('Error updating action date. Please try again.', 'danger');

                    // Reset to original date
                    e.target.value = originalDate;

                    // Re-enable the input and restore opacity
                    e.target.disabled = false;
                    row.style.opacity = originalOpacity;
                }
            });

            // 2. Action Status Toggle (using event delegation)
            document.addEventListener('change', async (e) => {
                if (!e.target.classList.contains('action-status-checkbox')) return;

                const checkbox = e.target;
                const actionId = checkbox.dataset.actionId;
                checkbox.disabled = true; // Prevent rapid clicks

                // Find the row in either table
                const row = document.querySelector(`tr[data-action-id="${actionId}"]`);
                if (!row) {
                    console.error('Row not found for action ID:', actionId);
                    checkbox.disabled = false;
                    return;
                }

                // Add a visual indicator that the action is being processed
                const originalOpacity = row.style.opacity || '1';
                row.style.opacity = '0.7';

                try {
                    const response = await fetch(`/actions/${actionId}/toggle-closed`, { method: 'POST' });
                    if (!response.ok) throw new Error('Status update failed.');

                    const updatedAction = await response.json();

                    // Find and update the action in our local state array
                    const actionIndex = userBacklogActions.findIndex(a => a.id == actionId);
                    if (actionIndex !== -1) {
                        userBacklogActions[actionIndex] = updatedAction;
                    }

                    // Remove the row from its current position
                    row.remove();

                    renderBacklog(); // Re-render the whole table from the updated state
                    const message = updatedAction.closed ? 'closed' : 'reopened';
                    showNotification(`Action ${actionId} ${message} successfully.`, 'success');

                } catch (error) {
                    console.error('Error toggling action status:', error);
                    showNotification('Error updating status.', 'danger');
                    checkbox.checked = !checkbox.checked; // Revert checkbox on failure

                    // Restore opacity on error
                    row.style.opacity = originalOpacity;
                    checkbox.disabled = false;
                }
            });

            // 3. Notes Modal Logic (using event delegation)
            document.addEventListener('click', e => {
                if (!e.target.classList.contains('notes-icon')) return;

                const icon = e.target;
                const actionId = icon.dataset.actionId;
                const accountId = icon.dataset.accountId;
                const notesContent = document.getElementById('notes-content');
                const saveNotesBtn = document.getElementById('save-notes-btn');

                document.getElementById('action-id-for-notes').value = actionId;
                notesContent.value = icon.dataset.notes || '';

                // Check if the action belongs to a disabled account
                // First check if the action row has the disabled-account-action class
                const actionRow = icon.closest('tr');
                const isDisabledAction = actionRow && actionRow.classList.contains('disabled-account-action');

                // If not, check the account status from the data attribute
                const accountCell = actionRow.querySelector('.action-account-cell');
                const accountStatus = accountCell ? accountCell.getAttribute('data-account-status') : 'active';
                const isDisabledAccount = accountStatus === 'disabled';

                // Make the text area read-only and hide the save button if the account is disabled
                if (isDisabledAccount || isDisabledAction) {
                    notesContent.readOnly = true;
                    saveNotesBtn.style.display = 'none';
                } else {
                    notesContent.readOnly = false;
                    saveNotesBtn.style.display = 'block';
                }

                notesModal.show();
            });

            // 4. Edit Date Button Click
            document.addEventListener('click', function(e) {
                const editBtn = e.target.closest('.edit-date-btn');
                if (!editBtn) return;

                const actionId = editBtn.getAttribute('data-action-id');
                const cell = editBtn.closest('.action-date-cell');

                // Check if this action belongs to a disabled account
                const actionRow = cell.closest('tr');
                if (actionRow && actionRow.classList.contains('disabled-account-action')) {
                    // Don't allow editing for disabled accounts
                    return;
                }

                const dateSpan = cell.querySelector('span');
                const currentDate = dateSpan.textContent.trim();

                // Create a date input
                const dateInput = document.createElement('input');
                dateInput.type = 'date';
                dateInput.className = 'form-control temp-date-picker';
                dateInput.setAttribute('data-action-id', actionId);

                // Try to convert the formatted date to YYYY-MM-DD for the input
                try {
                    // Parse the date correctly based on the displayed format (DD/MM/YYYY)
                    const dateParts = currentDate.split('/');
                    if (dateParts.length === 3) {
                        // Assuming format is DD/MM/YYYY
                        const day = dateParts[0];
                        const month = dateParts[1];
                        const year = dateParts[2];

                        // Create ISO 8601 format (YYYY-MM-DD)
                        const isoDate = `${year}-${month}-${day}`;
                        dateInput.value = isoDate;
                        dateInput.setAttribute('data-original-date', isoDate);
                    } else {
                        // Fallback for other formats
                        const parsedDate = new Date(currentDate);
                        if (!isNaN(parsedDate.getTime())) {
                            const yyyy = parsedDate.getFullYear();
                            const mm = String(parsedDate.getMonth() + 1).padStart(2, '0');
                            const dd = String(parsedDate.getDate()).padStart(2, '0');
                            const isoDate = `${yyyy}-${mm}-${dd}`;
                            dateInput.value = isoDate;
                            dateInput.setAttribute('data-original-date', isoDate);
                        }
                    }
                } catch (e) {
                    console.error('Error parsing date:', e);
                }

                // Create save and cancel buttons
                const saveBtn = document.createElement('button');
                saveBtn.type = 'button';
                saveBtn.className = 'btn btn-sm btn-success ms-2';
                saveBtn.innerHTML = '<i class="fas fa-check"></i>';

                const cancelBtn = document.createElement('button');
                cancelBtn.type = 'button';
                cancelBtn.className = 'btn btn-sm btn-secondary ms-1';
                cancelBtn.innerHTML = '<i class="fas fa-times"></i>';

                // Hide the current elements
                dateSpan.style.display = 'none';
                editBtn.style.display = 'none';

                // Add the new elements
                cell.appendChild(dateInput);
                cell.appendChild(saveBtn);
                cell.appendChild(cancelBtn);

                // Focus the date input
                dateInput.focus();

                // Function to reset the cell to its original state
                const resetCell = () => {
                    dateSpan.style.display = '';
                    editBtn.style.display = '';
                    dateInput.remove();
                    saveBtn.remove();
                    cancelBtn.remove();
                };

                // Handle cancel button click
                cancelBtn.addEventListener('click', resetCell);

                // Handle save button click
                saveBtn.addEventListener('click', async () => {
                    const newDate = dateInput.value;
                    if (!newDate) {
                        // If no date selected, just cancel
                        resetCell();
                        return;
                    }

                    // Find the row
                    const row = cell.closest('tr');
                    if (!row) {
                        console.error('Row not found for action ID:', actionId);
                        resetCell();
                        return;
                    }

                    // Add a visual indicator that the action is being processed
                    const originalOpacity = row.style.opacity || '1';
                    row.style.opacity = '0.7';

                    // Disable the input and buttons while processing
                    dateInput.disabled = true;
                    saveBtn.disabled = true;
                    cancelBtn.disabled = true;

                    try {
                        // Use the new backlog update endpoint with the date field
                        const response = await fetch(`/user/backlog/update-action-field/${actionId}`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/x-www-form-urlencoded',
                            },
                            body: `fieldName=date&newValue=${encodeURIComponent(newDate)}`
                        });

                        if (!response.ok) throw new Error('Network response was not ok');

                        const data = await response.json();

                        // Update the action in our stored array
                        const actionIndex = userBacklogActions.findIndex(a => a.id == actionId);
                        if (actionIndex !== -1) {
                            // Ensure data has the properties needed for UI rendering
                            // The server returns nextStepDate as the formatted date, but UI expects nextStepDateFormatted
                            data.nextStepDateFormatted = data.nextStepDate;

                            // Extract raw date (YYYY-MM-DD) from the input for styling purposes
                            data.nextStepDateRaw = newDate;

                            userBacklogActions[actionIndex] = data;
                        }

                        // Re-render the backlog to ensure proper sorting
                        renderBacklog();

                        // Show success notification
                        showNotification('Action date updated successfully', 'success');

                    } catch (error) {
                        console.error('Error updating action date:', error);
                        showNotification('Error updating action date. Please try again.', 'danger');

                        // Reset the cell
                        resetCell();

                        // Restore opacity
                        row.style.opacity = originalOpacity;
                    }
                });
            });

            // Handle Edit Account Button Click
            document.addEventListener('click', function(e) {
                const editBtn = e.target.closest('.edit-account-btn');
                if (!editBtn) return;

                const actionId = editBtn.getAttribute('data-action-id');
                const cell = editBtn.closest('.action-account-cell');
                const accountSpan = cell.querySelector('span');
                const currentAccount = accountSpan.textContent.trim();

                // Create a text input
                const accountInput = document.createElement('input');
                accountInput.type = 'text';
                accountInput.className = 'form-control';
                accountInput.value = currentAccount === 'N/A' ? '' : currentAccount;
                accountInput.setAttribute('data-action-id', actionId);

                // Create save and cancel buttons
                const saveBtn = document.createElement('button');
                saveBtn.type = 'button';
                saveBtn.className = 'btn btn-sm btn-success ms-2';
                saveBtn.innerHTML = '<i class="fas fa-check"></i>';

                const cancelBtn = document.createElement('button');
                cancelBtn.type = 'button';
                cancelBtn.className = 'btn btn-sm btn-secondary ms-1';
                cancelBtn.innerHTML = '<i class="fas fa-times"></i>';

                // Hide the current elements
                accountSpan.style.display = 'none';
                editBtn.style.display = 'none';

                // Add the new elements
                cell.appendChild(accountInput);
                cell.appendChild(saveBtn);
                cell.appendChild(cancelBtn);

                // Focus the input
                accountInput.focus();

                // Function to reset the cell to its original state
                const resetCell = () => {
                    accountSpan.style.display = '';
                    editBtn.style.display = '';
                    accountInput.remove();
                    saveBtn.remove();
                    cancelBtn.remove();
                };

                // Handle cancel button click
                cancelBtn.addEventListener('click', resetCell);

                // Handle save button click
                saveBtn.addEventListener('click', async () => {
                    const newAccount = accountInput.value;
                    if (!newAccount) {
                        // If no account entered, just cancel
                        resetCell();
                        return;
                    }

                    // Find the row
                    const row = cell.closest('tr');
                    if (!row) {
                        console.error('Row not found for action ID:', actionId);
                        resetCell();
                        return;
                    }

                    // Add a visual indicator that the action is being processed
                    const originalOpacity = row.style.opacity || '1';
                    row.style.opacity = '0.7';

                    // Disable the input and buttons while processing
                    accountInput.disabled = true;
                    saveBtn.disabled = true;
                    cancelBtn.disabled = true;

                    try {
                        const response = await fetch(`/user/backlog/update-action-field/${actionId}`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/x-www-form-urlencoded',
                            },
                            body: `fieldName=account&newValue=${encodeURIComponent(newAccount)}`
                        });

                        if (!response.ok) throw new Error('Network response was not ok');

                        const data = await response.json();

                        // Update the action in our stored array
                        const actionIndex = userBacklogActions.findIndex(a => a.id == actionId);
                        if (actionIndex !== -1) {
                            userBacklogActions[actionIndex] = data;
                        }

                        // Update the account span with the new value
                        accountSpan.textContent = data.accountName || 'N/A';

                        // Reset the cell to its original state but with the new account
                        resetCell();

                        // Show success notification
                        showNotification('Account updated successfully', 'success');
                    } catch (error) {
                        console.error('Error updating account:', error);
                        showNotification('Error updating account. Please try again.', 'danger');

                        // Reset the cell
                        resetCell();

                        // Restore opacity
                        row.style.opacity = originalOpacity;
                    }
                });
            });

            // Handle Edit Title Button Click
            document.addEventListener('click', function(e) {
                const editBtn = e.target.closest('.edit-title-btn');
                if (!editBtn) return;

                const actionId = editBtn.getAttribute('data-action-id');
                const cell = editBtn.closest('.action-title-cell');

                // Check if this action belongs to a disabled account
                const actionRow = cell.closest('tr');
                if (actionRow && actionRow.classList.contains('disabled-account-action')) {
                    // Don't allow editing for disabled accounts
                    return;
                }

                const titleSpan = cell.querySelector('span');
                const currentTitle = titleSpan.textContent.trim();

                // Create a text input
                const titleInput = document.createElement('input');
                titleInput.type = 'text';
                titleInput.className = 'form-control';
                titleInput.value = currentTitle;
                titleInput.setAttribute('data-action-id', actionId);

                // Create save and cancel buttons
                const saveBtn = document.createElement('button');
                saveBtn.type = 'button';
                saveBtn.className = 'btn btn-sm btn-success ms-2';
                saveBtn.innerHTML = '<i class="fas fa-check"></i>';

                const cancelBtn = document.createElement('button');
                cancelBtn.type = 'button';
                cancelBtn.className = 'btn btn-sm btn-secondary ms-1';
                cancelBtn.innerHTML = '<i class="fas fa-times"></i>';

                // Hide the current elements
                titleSpan.style.display = 'none';
                editBtn.style.display = 'none';

                // Add the new elements
                cell.appendChild(titleInput);
                cell.appendChild(saveBtn);
                cell.appendChild(cancelBtn);

                // Focus the input
                titleInput.focus();

                // Function to reset the cell to its original state
                const resetCell = () => {
                    titleSpan.style.display = '';
                    editBtn.style.display = '';
                    titleInput.remove();
                    saveBtn.remove();
                    cancelBtn.remove();
                };

                // Handle cancel button click
                cancelBtn.addEventListener('click', resetCell);

                // Handle save button click
                saveBtn.addEventListener('click', async () => {
                    const newTitle = titleInput.value;
                    if (!newTitle) {
                        // If no title entered, just cancel
                        resetCell();
                        return;
                    }

                    // Find the row
                    const row = cell.closest('tr');
                    if (!row) {
                        console.error('Row not found for action ID:', actionId);
                        resetCell();
                        return;
                    }

                    // Add a visual indicator that the action is being processed
                    const originalOpacity = row.style.opacity || '1';
                    row.style.opacity = '0.7';

                    // Disable the input and buttons while processing
                    titleInput.disabled = true;
                    saveBtn.disabled = true;
                    cancelBtn.disabled = true;

                    try {
                        const response = await fetch(`/user/backlog/update-action-field/${actionId}`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/x-www-form-urlencoded',
                            },
                            body: `fieldName=action&newValue=${encodeURIComponent(newTitle)}`
                        });

                        if (!response.ok) throw new Error('Network response was not ok');

                        const data = await response.json();

                        // Update the action in our stored array
                        const actionIndex = userBacklogActions.findIndex(a => a.id == actionId);
                        if (actionIndex !== -1) {
                            userBacklogActions[actionIndex] = data;
                        }

                        // Update the title span with the new value
                        titleSpan.textContent = data.title || '';

                        // Reset the cell to its original state but with the new title
                        resetCell();

                        // Show success notification
                        showNotification('Action updated successfully', 'success');
                    } catch (error) {
                        console.error('Error updating action:', error);
                        showNotification('Error updating action. Please try again.', 'danger');

                        // Reset the cell
                        resetCell();

                        // Restore opacity
                        row.style.opacity = originalOpacity;
                    }
                });
            });

            // Handle Edit Contact Button Click
            document.addEventListener('click', function(e) {
                const editBtn = e.target.closest('.edit-contact-btn');
                if (!editBtn) return;

                const actionId = editBtn.getAttribute('data-action-id');
                const cell = editBtn.closest('.action-contact-cell');

                // Check if this action belongs to a disabled account
                const actionRow = cell.closest('tr');
                if (actionRow && actionRow.classList.contains('disabled-account-action')) {
                    // Don't allow editing for disabled accounts
                    return;
                }

                const contactSpan = cell.querySelector('span');
                const currentContact = contactSpan.textContent.trim();

                // Create a dropdown for contacts
                const contactSelect = document.createElement('select');
                contactSelect.className = 'form-control';
                contactSelect.setAttribute('data-action-id', actionId);

                // Add a loading option
                const loadingOption = document.createElement('option');
                loadingOption.textContent = 'Loading contacts...';
                contactSelect.appendChild(loadingOption);

                // Get the account ID from the action
                const row = document.querySelector(`tr[data-action-id="${actionId}"]`);
                const accountId = row.querySelector('.action-account-cell').getAttribute('data-account-id');

                if (accountId && accountId !== 'null') {
                    // Fetch contacts for this account
                    fetch(`/accounts/${accountId}/contacts`)
                        .then(response => response.json())
                        .then(contacts => {
                            // Clear the loading option
                            contactSelect.innerHTML = '';

                            // Add an empty option
                            const emptyOption = document.createElement('option');
                            emptyOption.value = '';
                            emptyOption.textContent = 'Select Contact';
                            contactSelect.appendChild(emptyOption);

                            // Add options for each contact
                            if (contacts && contacts.length > 0) {
                                contacts.forEach(contact => {
                                    const option = document.createElement('option');
                                    option.value = contact;
                                    option.textContent = contact;
                                    // Pre-select the current contact
                                    if (contact === currentContact) {
                                        option.selected = true;
                                    }
                                    contactSelect.appendChild(option);
                                });
                            } else {
                                // If no contacts, add a default option
                                const option = document.createElement('option');
                                option.value = "No contacts available";
                                option.textContent = "No contacts available";
                                contactSelect.appendChild(option);
                            }
                        })
                        .catch(error => {
                            console.error('Error fetching contacts:', error);
                            contactSelect.innerHTML = '<option>Error loading contacts</option>';
                        });
                } else {
                    // If no account ID, just show a message
                    contactSelect.innerHTML = '<option value="">No account selected</option>';
                }

                // Create save and cancel buttons
                const saveBtn = document.createElement('button');
                saveBtn.type = 'button';
                saveBtn.className = 'btn btn-sm btn-success ms-2';
                saveBtn.innerHTML = '<i class="fas fa-check"></i>';

                const cancelBtn = document.createElement('button');
                cancelBtn.type = 'button';
                cancelBtn.className = 'btn btn-sm btn-secondary ms-1';
                cancelBtn.innerHTML = '<i class="fas fa-times"></i>';

                // Hide the current elements
                contactSpan.style.display = 'none';
                editBtn.style.display = 'none';

                // Add the new elements
                cell.appendChild(contactSelect);
                cell.appendChild(saveBtn);
                cell.appendChild(cancelBtn);

                // Focus the dropdown
                contactSelect.focus();

                // Function to reset the cell to its original state
                const resetCell = () => {
                    contactSpan.style.display = '';
                    editBtn.style.display = '';
                    contactSelect.remove();
                    saveBtn.remove();
                    cancelBtn.remove();
                };

                // Handle cancel button click
                cancelBtn.addEventListener('click', resetCell);

                // Handle save button click
                saveBtn.addEventListener('click', async () => {
                    const newContact = contactSelect.value;
                    if (!newContact) {
                        // If no contact selected, just cancel
                        resetCell();
                        return;
                    }

                    // Find the row
                    const row = cell.closest('tr');
                    if (!row) {
                        console.error('Row not found for action ID:', actionId);
                        resetCell();
                        return;
                    }

                    // Add a visual indicator that the action is being processed
                    const originalOpacity = row.style.opacity || '1';
                    row.style.opacity = '0.7';

                    // Disable the dropdown and buttons while processing
                    contactSelect.disabled = true;
                    saveBtn.disabled = true;
                    cancelBtn.disabled = true;

                    try {
                        const response = await fetch(`/user/backlog/update-action-field/${actionId}`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/x-www-form-urlencoded',
                            },
                            body: `fieldName=contact&newValue=${encodeURIComponent(newContact)}`
                        });

                        if (!response.ok) throw new Error('Network response was not ok');

                        const data = await response.json();

                        // Update the action in our stored array
                        const actionIndex = userBacklogActions.findIndex(a => a.id == actionId);
                        if (actionIndex !== -1) {
                            userBacklogActions[actionIndex] = data;
                        }

                        // Update the contact span with the new value
                        contactSpan.textContent = data.contact || '';

                        // Reset the cell to its original state but with the new contact
                        resetCell();

                        // Show success notification
                        showNotification('Contact updated successfully', 'success');
                    } catch (error) {
                        console.error('Error updating contact:', error);
                        showNotification('Error updating contact. Please try again.', 'danger');

                        // Reset the cell
                        resetCell();

                        // Restore opacity
                        row.style.opacity = originalOpacity;
                    }
                });
            });

            document.getElementById('save-notes-btn').addEventListener('click', async () => {
                const actionId = document.getElementById('action-id-for-notes').value;
                const notes = document.getElementById('notes-content').value;
                const formData = new URLSearchParams({ notes });

                try {
                    const response = await fetch(`/actions/${actionId}/update-notes`, {
                        method: 'POST',
                        body: formData
                    });
                    if (!response.ok) throw new Error('Failed to save notes.');

                    const updatedAction = await response.json();

                    const actionIndex = userBacklogActions.findIndex(a => a.id == actionId);
                    if (actionIndex !== -1) {
                        // Store the previous account ID and notes status
                        const accountId = userBacklogActions[actionIndex].accountId;
                        const hadNotesBefore = !!(userBacklogActions[actionIndex].notes && userBacklogActions[actionIndex].notes.trim());
                        const hasNotesNow = !!(updatedAction.notes && updatedAction.notes.trim());

                        // Update the action with the response data
                        userBacklogActions[actionIndex] = updatedAction;

                        // Ensure accountId is preserved (in case it's not returned by the API)
                        userBacklogActions[actionIndex].accountId = accountId;

                        // Update accountNotesCount for all actions with the same accountId
                        if (hadNotesBefore !== hasNotesNow) {
                            userBacklogActions.forEach(action => {
                                if (action.accountId === accountId) {
                                    // Increment or decrement the account notes count
                                    if (hasNotesNow && !hadNotesBefore) {
                                        action.accountNotesCount = (action.accountNotesCount || 0) + 1;
                                    } else if (!hasNotesNow && hadNotesBefore) {
                                        action.accountNotesCount = Math.max(0, (action.accountNotesCount || 0) - 1);
                                    }
                                }
                            });
                        }
                    }

                    renderBacklog();
                    notesModal.hide();
                    showNotification('Notes saved successfully.', 'success');

                } catch (error) {
                    console.error('Error saving notes:', error);
                    showNotification('Could not save notes.', 'danger');
                }
            });
        });
    </script>
{% endblock %}
